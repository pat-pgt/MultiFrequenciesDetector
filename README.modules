The configuration of the modules depends on many requirements about what is supplied and which result is expected.
Perhaps a future Python project is going to ask all the questions and configure.

There are 4 types of modules:
* Cordic stages configured to converge Z to 0, in order to get the X and the Y. The number of stages depends on the accuracy of the cordic.
* Cordic stages configured to converge Y to 0, in order to get the amplitude (X) and the phase (Z). The number of stages depends on the accuracy of the cordic.
* Prefilter. They are used to make a gross filtering with a minimum of resources for the down-sampling. It is one or more first order only modules.
* Strictly speaking, the down-sampling is not configurable. However it relays on the number of notes per octaves, the number of octaves, the sample rate (before) etc...
* Main filter. It is a one instance only, to make a fine filtering, and with a limited number of cut off frequencies, due to the down-sampling by a 2^octave ratio.
* Some modules monitor or inject the data.

The interconnection between the modules is the same for all of them. The assembly is done "like the LEGO". It helps for the test as well by by-passing, injecting or monitoring the data. For more information a picture, named overview is in the Documentation folder. The links are draw in green for the run and in red for the test modes.

The assume, of this project, is the bandwidth of each channel is very low in front of the sampling rate.
The multiplication by sine and cosine has to be filtered by the width of the channel (for each channel). The signal is going to be down-sampled for 2 reasons: the resources can be share by many channels and it is tricky to low pass filter with a high sample-rate on cut off ratio (high precision numbers). The down-sampling produces an aliasing. It is not always a problem. In our case the main filter is going to cut most of the aliased.
For instance, the sample-rate is 10KHz, the required cut-off is 100Hz, the prefilter cut-off of the pre-filter is 150Hz. A down-sampling by 2 need to get rid of frequencies over 2.5KHz. Frequencies between 2.5KHz and 4900Hz are aliased but cut by the main filter. The only one problem is the frequencies between 4900Hz and 5000Hz. The prefilter is going to attenuate *only* by 33.8dB these signals.


Details 
* The prefilter cut-off frequency impacts on the accuracy of the output amplitude. A higher value increases, but is worst for the aliasing. Since the numerical sine and cosine (pre)filters are absolutely identical, there is no impact on the phase output. For convenience, the ratio between the main filter and the pre-filter has to be configured, the code compute the details (in the example above 1.5).
* The number of pre-filter modules impact on the detection of low signals among high amplitude signals. See above, however, this has to be re-calculated against the actual sampling rate and channels widths.
* The main filter can be omitted. The entire can be built for PoC, until the day the main filter is written. It reduces the resources as no RAM module is required. Isolated signals appears as large Gaussian on the output, rather than "Dirac".
* The cordic algorithms converge a vector as decreasing oscillations around the destination. A worst case can be calculated. The decrease is fast on the beginning, but becomes more and more slow.
** For the Z to 0, the pseudo random error is equivalent to add a high frequency to the channel frequency. However, the amplitude is low. It is a problem only if there are high amplitude high frequency signals among the input. 
** For the Y to 0 stages, a couple of stages plus the pre-process place the vector in the -PI/10 to PI/10. The amplitude is accurate with an error of 5%. It is sufficient to see the phase spinning on a 4 quadrants display.